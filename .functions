echo "loading .functions......"

function pgrep {
  local exclude="\.svn|\.git|\.swp|\.coverage|\.pyc|_build"
  find . -maxdepth 1 -mindepth 1 | egrep -v "$exclude" | xargs egrep -lir "$1" | egrep -v "$exclude" | xargs egrep -Hin --color "$1"
}

function show-empty-folders {
    find . -depth -type d -empty
}

function kill-empty-folders {
    find . -depth -type d -empty -exec rmdir "{}" \;
}

# download book from zanghaihua.org
function DDL() {
	# get input number for the start~end page
	if [[ -n $StartPoint_PageNumber ]] && [[ -n $EndPoint_PageNumber ]]; then
		echo $StartPoint_PageNumber;
		echo $EndPoint_PageNumber;
	else 
		read -p "Start: $@"  StartPoint_PageNumber
		read -p "End: $@"  EndPoint_PageNumber
	fi

	# setup the home page address for download site
	SITE="http://www.zanghaihua.org/"
	echo "## Starting Download BookPage From $SITE"
  
	# get BOOKCONECT from target page
	for (( i=$StartPoint_PageNumber;i<=$EndPoint_PageNumber;i++ ))
	{
		# add Progressively increase for page number
		TARGET_PAGE=$i;
		TARGET_ADDRESS=$SITE$i".html";
		SOURCE_PAGE=/home7/tvctopin/public_html/tmp.html;
		curl -S -# $TARGET_ADDRESS > $SOURCE_PAGE;
		TARGET_TITLE=$(cat $SOURCE_PAGE | grep  "<title>" | sed -e 's/[<>a-z/]//g');
		TARGET_CONECT=$(cat $SOURCE_PAGE | grep  "BookText" | sed -e 's/[{<div class="bookcontent clearfix" id="BookText">}-<>0-9()a-z&A-Z/;]//g');
		TARGET_OUTPUT=/home7/tvctopin/public_html/book.html;
    
		# output the booktext to file
		echo >> $TARGET_OUTPUT;
		echo "$TARGET_TITLE" >> $TARGET_OUTPUT;
		echo >> $TARGET_OUTPUT;
		echo "From:"$TARGET_ADDRESS >> $TARGET_OUTPUT;
		echo $TARGET_CONECT >> $TARGET_OUTPUT;
		echo "___________________________________________________" >> $TARGET_OUTPUT;
		echo >> $TARGET_OUTPUT;
		echo >> $TARGET_OUTPUT;
	}
	rm -rf  $SOURCE_PAGE
	FinalBook=/home7/tvctopin/public_html/dbook.html
	rm -rf $FinalBook
	mv $TARGET_OUTPUT $FinalBook
	echo "## Done!! Getting Book From $StartPoint_PageNumber To $EndPoint_PageNumber, Save To $FinalBook "
	unset StartPoint_PageNumber
	unset EndPoint_PageNumber
}



# git setting
#function parse_git_dirty() {
#	[[ $(git status 2> /dev/null | tail -n1) != *"working directory clean"* ]] && echo "*"
#}

#function parse_git_branch() {
#	git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/\1$(parse_git_dirty)/"
#}


function parse_git_branch {
  branch_pattern="^# On branch ([^${IFS}]*)"
  remote_pattern_ahead="# Your branch is ahead of"
  remote_pattern_behind="# Your branch is behind"
  remote_pattern_ff="# Your branch (.*) can be fast-forwarded."
  diverge_pattern="# Your branch and (.*) have diverged"

  git_status="$(git status 2> /dev/null)"
  if [[ ! ${git_status} =~ ${branch_pattern} ]]; then
    # Rebasing?
    toplevel=$(git rev-parse --show-toplevel 2> /dev/null)
    [[ -z "$toplevel" ]] && return

    [[ -d "$toplevel/.git/rebase-merge" || -d "$toplevel/.git/rebase-apply" ]] && {
      sha_file="$toplevel/.git/rebase-merge/stopped-sha"
      [[ -e "$sha_file" ]] && {
        sha=`cat "${sha_file}"`
      }
      echo "${PINK}(rebase in progress)${COLOR_NONE} ${sha}"
    }
    return
  fi

  branch=${BASH_REMATCH[1]}

  # Dirty?
  if [[ ! ${git_status} =~ "working directory clean" ]]; then
    [[ ${git_status} =~ "modified:" ]] && {
      git_is_dirty="${RED}${LIGHTNING_BOLT}"
    }

    [[ ${git_status} =~ "Untracked files" ]] && {
      git_is_dirty="${git_is_dirty}${WHITE}${MIDDOT}"
    }

    [[ ${git_status} =~ "new file:" ]] && {
      git_is_dirty="${git_is_dirty}${LT_GREEN}+"
    }

    [[ ${git_status} =~ "deleted:" ]] && {
      git_is_dirty="${git_is_dirty}${RED}-"
    }

    [[ ${git_status} =~ "renamed:" ]] && {
      git_is_dirty="${git_is_dirty}${YELLOW}→"
    }
  fi

  # Are we ahead of, beind, or diverged from the remote?
  if [[ ${git_status} =~ ${remote_pattern_ahead} ]]; then
    remote="${YELLOW}${UP_ARROW}"
  elif [[ ${git_status} =~ ${remote_pattern_ff} ]]; then
    remote_ff="${WHITE}${FF_ARROW}"
  elif [[ ${git_status} =~ ${remote_pattern_behind} ]]; then
    remote="${YELLOW}${DOWN_ARROW}"
  elif [[ ${git_status} =~ ${diverge_pattern} ]]; then
    remote="${YELLOW}${UD_ARROW}"
  fi

  echo "${remote}${remote_ff}${GREEN}(${branch})${COLOR_NONE}${git_is_dirty}${COLOR_NONE}"
}

function setWindowTitle {
  case $TERM in
    *xterm*|ansi)
      echo -n -e "\033]0;$*\007"
      ;;
  esac
}

function set_prompt {
  [[ -n $HOMEBREW_DEBUG_INSTALL ]] && \
    homebrew_prompt="${BROWN}Homebrew:${COLOR_NONE} debugging ${HOMEBREW_DEBUG_INSTALL}\n"

  git_prompt="$(parse_git_branch)"
  export PS1="[\w] ${git_prompt}${COLOR_NONE}\n${homebrew_prompt}\$ "
  setWindowTitle "${PWD/$HOME/~}"
}
export PROMPT_COMMAND=set_prompt


function git-root {
  root=$(git rev-parse --git-dir 2> /dev/null)
  [[ -z "$root" ]] && root="."
  dirname $root
}


# Reveal current or provided folder in Path Finder
function pf {
  target_path="$(cd ${1:-"$PWD"} && PWD)"
  osascript<<END
tell app "Path Finder"
  reveal POSIX file("$target_path")
  activate
end tell
END
}

# Open a manpage in Preview, which can be saved to PDF
function pman {
   man -t "${1}" | open -f -a /Applications/Preview.app
}

# Open a manpage in the browser
function bman {
  man "${1}" | man2html | browser
}

function pgrep {
  local exclude="\.svn|\.git|\.swp|\.coverage|\.pyc|_build"
  find . -maxdepth 1 -mindepth 1 | egrep -v "$exclude" | xargs egrep -lir "$1" | egrep -v "$exclude" | xargs egrep -Hin --color "$1"
}

# auto source LDLIBPATH
## not done
function llDP() {
	MYPATHS=$(cat /home7/tvctopin/.ldrc | sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/:/g') 
	ALLPATH=\"${MYPATHS}\"; 
	export MYPATH=$ALLPATH
}


# my bash update command
## not done
function uB() {
	alias updateBash="source ~/dotfiles/bootstrap.sh -f; 
	cd ~/dotfiles; git add -A; 
	git commit -m 'update by sennychu, at: $(date '+%S:%M:%H %/ %d-%m-%Y')'; 
	git push origin master;"
}

# my linux server shell-env upload to Github Repo
## not done
function dotUp() {
	echo "Upload the tvctop.info-Shell-Env-Profile to Github,"
	echo "see more https://github.com/sennychu/linux-dotfiles. "
	echo # newline
	Server_Repository=/home7/tvctopin/linux-dotfiles
	cd $Server_Repository
	set -- -f; source bootstrap.sh
	git add -A; git commit -m "update by SC,from tvctop.info"; git push
}

# homebrew function shotcut, unlink then remove the pkg
function bR() {
	brew unlink "$@" && brew uninstall "$@"
}

# extract the xz filepackeg,and go to the extract path
function uXz() {
	extractdir=/home7/tvctopin/var/tmp
	filename="$@"
	realname="$(echo $filename | sed  -e "s/.tar.xz//")"
	xz -dc $filename  | tar -xpf -
	mv ./$realname $extractdir
	cd "$extractdir/$realname" && echo "Done!!"
}

# extract the bz2 filepackeg,and go to the extract path
function uBz() {
	extractdir=/home7/tvctopin/var/tmp
	filename="$@"
	realname="$(echo $filename | sed  -e "s/.tar.bz2//")"
	bzcat $filename | tar -xf -    
	mv ./$realname $extractdir
	cd "$extractdir/$realname" && echo "Done!!"
}

# download and extract the brew pkg,just work for homebrew's pkg
function bD() {
	extractdir=/home7/tvctopin/var/tmp
	pkgname="$@"
	brew unpack --destdir=$extractdir -v $pkgname
	echo "Done!!"
}

# Simple calculator
function calc() {
	local result=""
	result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
	#                       └─ default (when `--mathlib` is used) is 20
	#
	if [[ "$result" == *.* ]]; then
		# improve the output for decimal numbers
		printf "$result" |
		sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
		    -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
		    -e 's/0*$//;s/\.$//'   # remove trailing zeros
	else
		printf "$result"
	fi
	printf "\n"
}
 
# Create a new directory and enter it
function mkd() {
	mkdir -p "$@" && cd "$@"
}
 
# Change working directory to the top-most Finder window location
function cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}
 
# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
function targz() {
	local tmpFile="${@%/}.tar"
	tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1
 
	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
	)
 
	local cmd=""
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli"
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz"
		else
			cmd="gzip"
		fi
	fi
 
	echo "Compressing .tar using \`${cmd}\`…"
	"${cmd}" -v "${tmpFile}" || return 1
	[ -f "${tmpFile}" ] && rm "${tmpFile}"
	echo "${tmpFile}.gz created successfully."
}
 
# Determine size of a file or total size of a directory
function fs() {
	if du -b /dev/null > /dev/null 2>&1; then
		local arg=-sbh
	else
		local arg=-sh
	fi
	if [[ -n "$@" ]]; then
		du $arg -- "$@"
	else
		du $arg .[^.]* *
	fi
}
 
# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi
 
# Create a data URL from a file
function dataurl() {
	local mimeType=$(file -b --mime-type "$1")
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8"
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}
 
# Create a git.io short URL
function gitio() {
	if [ -z "${1}" -o -z "${2}" ]; then
		echo "Usage: \`gitio slug url\`"
		return 1
	fi
	curl -i http://git.io/ -F "url=${2}" -F "code=${1}"
}
 
# Start an HTTP server from a directory, optionally specifying the port
function server() {
	local port="${1:-8000}"
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}
 
# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
function phpserver() {
	local port="${1:-4000}"
	local ip=$(ipconfig getifaddr en1)
	sleep 1 && open "http://${ip}:${port}/" &
	php -S "${ip}:${port}"
}
 
# Compare original and gzipped file size
function gz() {
	local origsize=$(wc -c < "$1")
	local gzipsize=$(gzip -c "$1" | wc -c)
	local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
	printf "orig: %d bytes\n" "$origsize"
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}
 
# Syntax-highlight JSON strings or files
# Usage: `json '{"foo":42}'` or `echo '{"foo":42}' | json`
function json() {
	if [ -t 0 ]; then # argument
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	else # pipe
		python -mjson.tool | pygmentize -l javascript
	fi
}
 
# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}
 
# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}
 
# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}
 
# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	# print a newline unless we’re piping the output to another program
	if [ -t 1 ]; then
		echo # newline
	fi
}
 
# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
function getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified."
		return 1
	fi
 
	local domain="${1}"
	echo "Testing ${domain}…"
	echo # newline
 
	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" 2>&1);
 
	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_header, no_serial, no_version, \
			no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
			echo "Common Name:"
			echo # newline
			echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
			echo # newline
			echo "Subject Alternative Name(s):"
			echo # newline
			echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
				| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
			return 0
	else
		echo "ERROR: Certificate not found.";
		return 1
	fi
}
 
# Install Grunt plugins and add them as `devDependencies` to `package.json`
# Usage: `gi contrib-watch contrib-uglify zopfli`
function gi() {
  local IFS=,
  eval npm install --save-dev grunt-{"$*"}
}

function newgit() {
  if [ -z $1 ]; then
    echo "usage: $FUNCNAME project-name.git"
  else
    gitdir="/home27/tvctopin/repositories/$1"
    mkdir $gitdir
    pushd $gitdir
    git --bare init
    git --bare update-server-info
    cp hooks/post-update.sample hooks/post-update
    chmod a+x hooks/post-update
    touch git-daemon-export-ok
    popd
  fi
}
 
